привет, у меня есть код проекта, исправь и улучши его, а так же, добавь в него больше возможностей, функций, и, переработай его дизайн, чтобы он был красивым:"""import os
import secrets
import json
import threading
from datetime import datetime, timedelta

from flask import Flask, render_template, request, redirect, url_for, session, jsonify, flash
from flask_socketio import SocketIO, emit, join_room, leave_room
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash

# Импортируем модули для выполнения кода (путь к ним не меняется)
from execution.python_exec import execute_python
from execution.cpp_exec import execute_cpp
from execution.csharp_exec import execute_csharp
from execution.java_exec import execute_java
from execution.javascript_exec import execute_javascript
from execution.go_exec import execute_go
from execution.ruby_exec import execute_ruby
from execution.rust_exec import execute_rust
from execution.php_exec import execute_php
from execution.swift_exec import execute_swift
from execution.kotlin_exec import execute_kotlin
from execution.scala_exec import execute_scala
from execution.haskell_exec import execute_haskell
from execution.perl_exec import execute_perl
from execution.r_exec import execute_r
from execution.bash_exec import execute_bash
from execution.typescript_exec import execute_typescript
from execution.lua_exec import execute_lua
from execution.dart_exec import execute_dart
from execution.julia_exec import execute_julia

app = Flask(__name__)
app.config['SECRET_KEY'] = secrets.token_hex(16)
app.config['SESSION_COOKIE_SECURE'] = False # True для HTTPS, False для HTTP (локальная разработка)
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['REMEMBER_COOKIE_DURATION'] = timedelta(days=30)

# Настройка SQLAlchemy
# SQLite база данных будет сохранена в файле site.db в корне проекта
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False # Отключаем отслеживание изменений, чтобы избежать предупреждений
db = SQLAlchemy(app)

socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading', logger=True, engineio_logger=True)

login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login' # Перенаправляем на '/login', если не авторизован

# --- Модели Базы Данных ---
class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(20), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    # Связь с сессиями, где пользователь является владельцем
    owned_sessions = db.relationship('CodeSession', backref='owner', lazy=True)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f"User('{self.username}', ID: {self.id})"

class CodeSession(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    session_id_str = db.Column(db.String(32), unique=True, nullable=False) # Уникальный публичный ID
    code = db.Column(db.Text, nullable=False, default='')
    language = db.Column(db.String(50), nullable=False, default='python')
    output = db.Column(db.Text, nullable=False, default='')
    is_locked = db.Column(db.Boolean, nullable=False, default=False)
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    last_active = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    owner_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True) # Может быть null, если анонимно

    def __repr__(self):
        return f"CodeSession('{self.session_id_str}', Lang: '{self.language}', Locked: {self.is_locked})"

# --- Инициализация Базы Данных ---
# Создаем таблицы, если их нет
with app.app_context():
    db.create_all()

# --- Flask-Login User Loader ---
@login_manager.user_loader
def load_user(user_id):
    return db.session.get(User, int(user_id)) # Используем db.session.get для получения пользователя по PK

# --- Вспомогательные функции для сессий ---
def get_session_from_db(session_id_str):
    """Получает сессию из базы данных по строковому ID."""
    s = db.session.execute(db.select(CodeSession).filter_by(session_id_str=session_id_str)).scalar_one_or_none()
    if s:
        s.last_active = datetime.utcnow()
        db.session.commit()
    return s

def create_new_session_in_db(language='python', owner_id=None):
    """Создает новую сессию в базе данных."""
    new_session_id_str = secrets.token_hex(8)
    new_session = CodeSession(
        session_id_str=new_session_id_str,
        language=language,
        owner_id=owner_id,
        created_at=datetime.utcnow(),
        last_active=datetime.utcnow()
    )
    db.session.add(new_session)
    db.session.commit()
    return new_session_id_str

# Список доступных языков и их исполнителей
AVAILABLE_LANGUAGES = {
    'python': {'name': 'Python', 'executor': execute_python},
    'cpp': {'name': 'C++', 'executor': execute_cpp},
    'csharp': {'name': 'C#', 'executor': execute_csharp},
    'java': {'name': 'Java', 'executor': execute_java},
    'javascript': {'name': 'JavaScript', 'executor': execute_javascript},
    'go': {'name': 'Go', 'executor': execute_go},
    'ruby': {'name': 'Ruby', 'executor': execute_ruby},
    'rust': {'name': 'Rust', 'executor': execute_rust},
    'php': {'name': 'PHP', 'executor': execute_php},
    'swift': {'name': 'Swift', 'executor': execute_swift},
    'kotlin': {'name': 'Kotlin', 'executor': execute_kotlin},
    'scala': {'name': 'Scala', 'executor': execute_scala},
    'haskell': {'name': 'Haskell', 'executor': execute_haskell},
    'perl': {'name': 'Perl', 'executor': execute_perl},
    'r': {'name': 'R', 'executor': execute_r},
    'bash': {'name': 'Bash', 'executor': execute_bash},
    'typescript': {'name': 'TypeScript', 'executor': execute_typescript},
    'lua': {'name': 'Lua', 'executor': execute_lua},
    'dart': {'name': 'Dart', 'executor': execute_dart},
    'julia': {'name': 'Julia', 'executor': execute_julia},
}

# --- Маршруты Flask ---

@app.route('/')
def index():
    if not current_user.is_authenticated:
        return redirect(url_for('login'))
    return render_template('index.html', languages=AVAILABLE_LANGUAGES)

@app.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        # Проверка на существующего пользователя
        existing_user = db.session.execute(db.select(User).filter_by(username=username)).scalar_one_or_none()
        if existing_user:
            flash('Имя пользователя уже занято. Выберите другое.', 'danger')
            return render_template('register.html')
        
        new_user = User(username=username)
        new_user.set_password(password)
        db.session.add(new_user)
        db.session.commit()
        flash('Вы успешно зарегистрированы! Теперь вы можете войти.', 'success')
        return redirect(url_for('login'))
    return render_template('register.html')


@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        user = db.session.execute(db.select(User).filter_by(username=username)).scalar_one_or_none()
        
        if user and user.check_password(password):
            login_user(user, remember=True)
            return redirect(url_for('index'))
        else:
            flash('Неправильное имя пользователя или пароль', 'danger')
        return render_template('login.html')
    return render_template('login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    flash('Вы вышли из системы.', 'info')
    return redirect(url_for('login'))

@app.route('/new_session', methods=['POST'])
@login_required
def new_session():
    language = request.form.get('language', 'python')
    if language not in AVAILABLE_LANGUAGES:
        language = 'python' # Дефолтный язык, если передан некорректный
    
    owner_id = current_user.id if current_user.is_authenticated else None
    session_id_str = create_new_session_in_db(language, owner_id)
    
    # ИСПРАВЛЕНО: используем session_id_str=
    return redirect(url_for('code_editor', session_id_str=session_id_str))

@app.route('/session/<session_id_str>')
@login_required
def code_editor(session_id_str):
    s = get_session_from_db(session_id_str)
    if not s:
        flash("Сессия не найдена.", 'danger')
        return redirect(url_for('index'))
    
    # Передаем статус блокировки и является ли текущий пользователь владельцем
    is_owner = current_user.is_authenticated and s.owner_id == current_user.id
    
    return render_template('editor.html', 
                           session_id=session_id_str, # Здесь передаем как session_id для использования в JS
                           initial_code=s.code, 
                           initial_language=s.language, 
                           initial_output=s.output, 
                           initial_lock_status=s.is_locked, 
                           languages=AVAILABLE_LANGUAGES,
                           is_owner=is_owner)

@app.route('/join_session', methods=['POST'])
@login_required
def join_session():
    session_id_str = request.form.get('session_id')
    s = get_session_from_db(session_id_str)
    if s:
        # ИСПРАВЛЕНО: используем session_id_str=
        return redirect(url_for('code_editor', session_id_str=session_id_str))
    flash('Сессия с таким ID не найдена.', 'danger')
    return redirect(url_for('index'))

@app.route('/toggle_lock/<session_id_str>', methods=['POST'])
@login_required
def toggle_lock_endpoint(session_id_str):
    s = get_session_from_db(session_id_str)
    if not s:
        return jsonify({'success': False, 'message': 'Сессия не найдена'}), 404
    
    # Только владелец может переключать блокировку
    if current_user.is_authenticated and s.owner_id == current_user.id:
        s.is_locked = not s.is_locked
        db.session.commit()
        lock_status = s.is_locked
        
        socketio.emit('lock_status_changed', {'is_locked': lock_status, 'session_id': session_id_str}, room=session_id_str)
        return jsonify({'success': True, 'is_locked': lock_status})
    else:
        return jsonify({'success': False, 'message': 'У вас нет прав для изменения статуса блокировки.'}), 403


# --- SocketIO Обработчики ---

@socketio.on('connect')
def handle_connect():
    print(f'Client connected: {request.sid}')

@socketio.on('disconnect')
def handle_disconnect():
    print(f'Client disconnected: {request.sid}')

@socketio.on('join')
def on_join(data):
    session_id_str = data.get('session_id')
    if not session_id_str:
        emit('error', {'message': 'Session ID is missing.'})
        return

    s = get_session_from_db(session_id_str)
    if not s:
        emit('error', {'message': 'Session not found.'})
        return

    join_room(session_id_str)
    
    # Проверка владельца для правильного отображения кнопок блокировки на клиенте
    is_owner = current_user.is_authenticated and s.owner_id == current_user.id

    emit('initial_state', { # Изменено на initial_state для комплексного обновления
        'code': s.code, 
        'language': s.language, 
        'output': s.output, 
        'is_locked': s.is_locked,
        'is_owner': is_owner # Передаем информацию о владельце
    }, room=request.sid)
    print(f'{request.sid} joined room {session_id_str}')

@socketio.on('leave')
def on_leave(data):
    session_id_str = data.get('session_id')
    if session_id_str:
        leave_room(session_id_str)
        print(f'{request.sid} left room {session_id_str}')

@socketio.on('code_change')
def handle_code_change(data):
    session_id_str = data.get('session_id')
    new_code = data.get('code')
    
    if not session_id_str or new_code is None:
        return

    s = get_session_from_db(session_id_str)
    if not s:
        return

    # Проверяем статус блокировки. Только владелец может менять код, если заблокировано.
    if s.is_locked and (not current_user.is_authenticated or s.owner_id != current_user.id):
        # Если заблокировано, и это не владелец, не обновляем код
        # и отправляем текущий код обратно клиенту, который пытался изменить
        emit('code_update', {'code': s.code, 'session_id': session_id_str}, room=request.sid)
        return

    s.code = new_code
    s.last_active = datetime.utcnow()
    db.session.commit()
    
    emit('code_update', {'code': new_code, 'session_id': session_id_str}, room=session_id_str, skip_sid=request.sid)


@socketio.on('language_change')
def handle_language_change(data):
    session_id_str = data.get('session_id')
    new_language = data.get('language')

    if not session_id_str or new_language not in AVAILABLE_LANGUAGES:
        return

    s = get_session_from_db(session_id_str)
    if not s:
        return

    # Проверяем статус блокировки
    if s.is_locked and (not current_user.is_authenticated or s.owner_id != current_user.id):
        emit('language_update', {'language': s.language, 'session_id': session_id_str}, room=request.sid)
        return

    s.language = new_language
    s.last_active = datetime.utcnow()
    db.session.commit()
    
    emit('language_update', {'language': new_language, 'session_id': session_id_str}, room=session_id_str)


@socketio.on('execute_code')
def handle_execute_code(data):
    session_id_str = data.get('session_id')
    
    s = get_session_from_db(session_id_str)
    if not s:
        emit('execution_result', {'output': 'Ошибка: Сессия не найдена.', 'session_id': session_id_str}, room=request.sid)
        return

    code_to_execute = s.code
    language = s.language

    executor_info = AVAILABLE_LANGUAGES.get(language)
    if not executor_info:
        emit('execution_result', {'output': f'Ошибка: Исполнитель для языка "{language}" не найден.', 'session_id': session_id_str}, room=request.sid)
        return

    executor_func = executor_info['executor']
    
    def run_execution():
        print(f"Executing code for session {session_id_str} ({language})...")
        result = executor_func(code_to_execute)
        
        output = result.get('output', '')
        error = result.get('error', '')
        
        final_output = output + (f"\n\nОшибка:\n{error}" if error else "")

        # Важно: В новом потоке нужно получить свежую сессию из БД
        # или использовать app.app_context() для работы с db.session
        with app.app_context(): 
            s_in_thread = db.session.execute(db.select(CodeSession).filter_by(session_id_str=session_id_str)).scalar_one_or_none()
            if s_in_thread: # Убедимся, что сессия все еще существует
                s_in_thread.output = final_output
                s_in_thread.last_active = datetime.utcnow()
                db.session.commit() # Сохраняем изменения в базе данных
                
            socketio.emit('execution_result', {'output': final_output, 'session_id': session_id_str}, room=session_id_str)
            print(f"Execution finished for session {session_id_str}. Output length: {len(final_output)}")

    threading.Thread(target=run_execution).start()

# --- Логика очистки старых сессий ---
def cleanup_old_sessions():
    """Удаляет старые сессии из базы данных, которые неактивны более 1 часа."""
    with app.app_context(): # Необходимо для доступа к db.session
        while True:
            current_time = datetime.utcnow()
            # Удаляем сессии, которые неактивны более 1 часа
            old_sessions = db.session.execute(
                db.select(CodeSession).filter(CodeSession.last_active < current_time - timedelta(hours=1))
            ).scalars().all()
            
            for s in old_sessions:
                db.session.delete(s)
                print(f"Сессия {s.session_id_str} удалена из-за неактивности.")
            db.session.commit()
            
            threading.Event().wait(1800) # Проверяем каждые 30 минут

cleanup_thread = threading.Thread(target=cleanup_old_sessions)
cleanup_thread.daemon = True 
cleanup_thread.start()


if __name__ == '__main__':
    print("Starting Flask-SocketIO server...")
    socketio.run(app, debug=True, allow_unsafe_werkzeug=True)
""", """# auth.py
from flask import Blueprint, render_template, redirect, url_for, flash
from flask_login import login_user, logout_user, login_required
from werkzeug.security import generate_password_hash, check_password_hash
from .models import User
from . import db, login_manager

auth = Blueprint('auth', __name__)

@login_manager.user_loader
def load_user(user_id):
    return User.get(user_id)

@auth.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        user_id = db.hget('user_index', username)
        if not user_id:
            flash('Invalid username')
            return redirect(url_for('auth.login'))
            
        user = User.get(user_id)
        if not user or not check_password_hash(user.password_hash, password):
            flash('Invalid password')
            return redirect(url_for('auth.login'))
            
        login_user(user)
        return redirect(url_for('main.index'))
    
    return render_template('login.html')

@auth.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        
        if db.hexists('user_index', username):
            flash('Username already exists')
            return redirect(url_for('auth.register'))
            
        user_id = str(uuid.uuid4())
        password_hash = generate_password_hash(password)
        
        db.hset(f'user:{user_id}', mapping={
            'username': username,
            'password_hash': password_hash,
            'created_at': datetime.now().isoformat()
        })
        db.hset('user_index', username, user_id)
        
        user = User(user_id, username, password_hash)
        login_user(user)
        flash('Registration successful')
        return redirect(url_for('main.index'))
    
    return render_template('register.html')

@auth.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('auth.login'))""", """<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Code Sync{% endblock %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
</head>
<body>
    <div class="theme-toggle-container">
        <button id="theme-toggle" class="btn btn-sm btn-outline-secondary">
            <i class="bi bi-moon-fill"></i> <span class="d-none d-md-inline">Темная тема</span>
        </button>
    </div>

    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            <div class="container mt-3">
                {% for category, message in messages %}
                    <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                        {{ message }}
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    </div>
                {% endfor %}
            </div>
        {% endif %}
    {% endwith %}
    
    {% block content %}{% endblock %}
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    {% block scripts %}{% endblock %}
    
    <script>
        const themeToggleBtn = document.getElementById('theme-toggle');
        // Load theme from localStorage, default to light
        const currentTheme = localStorage.getItem('theme') || 'light';

        // Apply theme on page load
        document.body.classList.add(currentTheme + '-theme');
        // Set button icon based on current theme
        if (currentTheme === 'dark') {
            themeToggleBtn.innerHTML = '<i class="bi bi-sun-fill"></i> <span class="d-none d-md-inline">Светлая тема</span>';
        } else {
            themeToggleBtn.innerHTML = '<i class="bi bi-moon-fill"></i> <span class="d-none d-md-inline">Темная тема</span>';
        }

        // Add event listener to toggle theme
        themeToggleBtn.addEventListener('click', () => {
            let theme = document.body.classList.contains('dark-theme') ? 'light' : 'dark';
            
            // Remove existing themes and add the new one
            document.body.classList.remove('light-theme', 'dark-theme');
            document.body.classList.add(theme + '-theme');
            
            // Save theme preference
            localStorage.setItem('theme', theme);

            // Update button icon and text
            if (theme === 'dark') {
                themeToggleBtn.innerHTML = '<i class="bi bi-sun-fill"></i> <span class="d-none d-md-inline">Светлая тема</span>';
            } else {
                themeToggleBtn.innerHTML = '<i class="bi bi-moon-fill"></i> <span class="d-none d-md-inline">Темная тема</span>';
            }
        });

        // Function to show custom toasts
        function showToast(message, type = 'info', delay = 3000) {
            const toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                console.error("Toast container not found!");
                return;
            }

            const toast = document.createElement('div');
            toast.className = `toast align-items-center text-white bg-${type} border-0 show`;
            toast.setAttribute('role', 'alert');
            toast.setAttribute('aria-live', 'assertive');
            toast.setAttribute('aria-atomic', 'true');
            toast.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
            `;
            toastContainer.appendChild(toast);

            setTimeout(() => {
                const bsToast = new bootstrap.Toast(toast, { delay: delay });
                bsToast.hide();
                toast.addEventListener('hidden.bs.toast', () => {
                    toast.remove();
                });
            }, delay);
        }
    </script>
</body>
</html>
""", """<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeSpace - Сессия {{ session_id }}</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css">
    <style>
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background-color: #f8f9fa;
        }
        .navbar {
            flex-shrink: 0;
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }
        .editor-container, .output-container {
            border: 1px solid #ddd;
            border-radius: 5px;
            overflow: hidden;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,.05);
        }
        .editor-wrapper {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 60vh; /* Устанавливаем высоту для редактора */
            margin-bottom: 20px;
        }
        .CodeMirror {
            height: 100%;
            font-size: 1.1em;
            line-height: 1.5;
        }
        .output-container {
            height: 30vh; /* Устанавливаем высоту для вывода */
            padding: 15px;
            overflow-y: auto;
            background-color: #333;
            color: #eee;
            font-family: monospace;
            white-space: pre-wrap; /* Сохраняет пробелы и переводы строк, переносит длинные строки */
        }
        .controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        .controls .form-control {
            margin-right: 10px;
        }
        .session-info {
            font-size: 0.9em;
            color: #666;
            margin-left: auto; /* Прижимает к правому краю */
        }
        .lock-status-icon {
            margin-left: 10px;
            cursor: pointer;
            font-size: 1.2em;
            color: gray;
        }
        .lock-status-icon.locked {
            color: red;
        }
        .lock-status-icon.unlocked {
            color: green;
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <a class="navbar-brand" href="/">CodeSpace</a>
        <span class="navbar-text ml-auto">
            {% if current_user.is_authenticated %}
            Привет, {{ current_user.username }}! &nbsp;
            <a class="btn btn-sm btn-outline-light" href="{{ url_for('logout') }}">Выйти</a>
            {% else %}
            <a class="btn btn-sm btn-outline-light" href="{{ url_for('login') }}">Войти</a>
            {% endif %}
        </span>
    </nav>

    <div class="main-content container-fluid">
        <div class="row">
            <div class="col-12">
                <div class="controls">
                    <label for="languageSelect" class="sr-only">Язык:</label>
                    <select class="form-control col-md-2" id="languageSelect">
                        {% for lang_key, lang_info in languages.items() %}
                        <option value="{{ lang_key }}" {% if lang_key == initial_language %}selected{% endif %}>{{ lang_info.name }}</option>
                        {% endfor %}
                    </select>
                    <button class="btn btn-primary ml-2" id="runCode">Выполнить код</button>
                    <span class="session-info ml-auto">
                        ID Сессии: <strong id="session-id-display">{{ session_id }}</strong>
                        {% if is_owner %}
                        <span id="lock-status-icon" class="lock-status-icon" title="Блокировка редактора">
                            {% if initial_lock_status %} &#128274; {% else %} &#128275; {% endif %}
                        </span>
                        {% endif %}
                    </span>
                </div>
            </div>
        </div>
        <div class="row editor-wrapper">
            <div class="col-12 editor-container">
                <textarea id="codeEditor">{{ initial_code }}</textarea>
            </div>
        </div>
        <div class="row">
            <div class="col-12 output-container">
                <pre id="outputArea">{{ initial_output }}</pre>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/clike/clike.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/ruby/ruby.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/rust/rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/php/php.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/haskell/haskell.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/perl/perl.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/r/r.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/shell/shell.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/lua/lua.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script>
        const sessionId = "{{ session_id }}";
        const initialLanguage = "{{ initial_language }}";
        let initialLockStatus = {{ 'true' if initial_lock_status else 'false' }};
        const isOwner = {{ 'true' if is_owner else 'false' }};

        let editor;
        let socket;
        let isCodeUpdateFromSocket = false; // Флаг для отслеживания обновлений из сокета
        let editorLocked = initialLockStatus;

        // Карта языков для CodeMirror modes
        const languageModes = {
            'python': 'python',
            'cpp': 'text/x-c++src',
            'csharp': 'text/x-csharp',
            'java': 'text/x-java',
            'javascript': 'javascript',
            'go': 'text/x-go',
            'ruby': 'ruby',
            'rust': 'rust',
            'php': 'php',
            'swift': 'text/x-swift',
            'kotlin': 'text/x-kotlin',
            'scala': 'text/x-scala',
            'haskell': 'haskell',
            'perl': 'perl',
            'r': 'r',
            'bash': 'shell',
            'typescript': 'text/typescript',
            'lua': 'lua',
            'dart': 'text/x-dart',
            'julia': 'text/x-julia' 
        };

        function setEditorMode(language) {
            const mode = languageModes[language] || 'text/plain';
            editor.setOption("mode", mode);
            CodeMirror.autoLoadMode(editor, mode); 
        }

        function updateLockIcon() {
            const icon = document.getElementById('lock-status-icon');
            if (icon) { // Проверяем, существует ли иконка (она показывается только владельцу)
                if (editorLocked) {
                    icon.innerHTML = '&#128274;'; // Замок закрыт
                    icon.classList.remove('unlocked');
                    icon.classList.add('locked');
                } else {
                    icon.innerHTML = '&#128275;'; // Замок открыт
                    icon.classList.remove('locked');
                    icon.classList.add('unlocked');
                }
            }
            // Устанавливаем readOnly для редактора в зависимости от блокировки И того, является ли пользователь владельцем
            editor.setOption('readOnly', editorLocked && !isOwner);
        }

        document.addEventListener('DOMContentLoaded', () => {
            editor = CodeMirror.fromTextArea(document.getElementById('codeEditor'), {
                lineNumbers: true,
                mode: languageModes[initialLanguage] || 'text/plain',
                theme: 'dracula',
                indentUnit: 4,
                tabSize: 4,
                indentWithTabs: true,
                readOnly: initialLockStatus && !isOwner // ReadOnly если заблокировано И не владелец
            });

            setEditorMode(initialLanguage);
            updateLockIcon(); // Обновляем иконку и состояние readOnly

            socket = io();

            socket.on('connect', () => {
                console.log('Connected to WebSocket server');
                socket.emit('join', { session_id: sessionId });
            });

            socket.on('disconnect', () => {
                console.log('Disconnected from WebSocket server');
            });

            // Обновленное событие initial_state
            socket.on('initial_state', (data) => {
                isCodeUpdateFromSocket = true;
                editor.setValue(data.code);
                isCodeUpdateFromSocket = false;
                
                document.getElementById('languageSelect').value = data.language;
                setEditorMode(data.language);

                initialLockStatus = data.is_locked; // Обновляем локальное состояние начальной блокировки
                editorLocked = data.is_locked;
                updateLockIcon();

                document.getElementById('outputArea').textContent = data.output;
                console.log('Initial state (code, language, output, lock status, owner status) received.');
            });

            socket.on('code_update', (data) => {
                if (data.session_id === sessionId) {
                    if (!isCodeUpdateFromSocket) {
                         isCodeUpdateFromSocket = true;
                        if (editor.getValue() !== data.code) {
                            editor.setValue(data.code);
                        }
                        isCodeUpdateFromSocket = false;
                    }
                }
            });

            socket.on('language_update', (data) => {
                if (data.session_id === sessionId) {
                    document.getElementById('languageSelect').value = data.language;
                    setEditorMode(data.language);
                }
            });

            socket.on('execution_result', (data) => {
                if (data.session_id === sessionId) {
                    document.getElementById('outputArea').textContent = data.output;
                }
            });

            socket.on('lock_status_changed', (data) => {
                if (data.session_id === sessionId) {
                    editorLocked = data.is_locked;
                    updateLockIcon(); // Обновляем иконку и readOnly
                    console.log('Lock status changed:', editorLocked);
                }
            });

            socket.on('error', (data) => {
                console.error('WebSocket Error:', data.message);
                alert('Ошибка: ' + data.message);
            });

            // Debounce для отправки изменений кода
            let debounceTimeout;
            editor.on('change', () => {
                if (isCodeUpdateFromSocket) {
                    return; 
                }
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(() => {
                    socket.emit('code_change', { session_id: sessionId, code: editor.getValue() });
                }, 250); 
            });

            document.getElementById('languageSelect').addEventListener('change', (event) => {
                const newLanguage = event.target.value;
                setEditorMode(newLanguage);
                socket.emit('language_change', { session_id: sessionId, language: newLanguage });
            });

            document.getElementById('runCode').addEventListener('click', () => {
                document.getElementById('outputArea').textContent = 'Выполнение...';
                socket.emit('execute_code', { session_id: sessionId });
            });

            // Обработчик кнопки блокировки, только если пользователь является владельцем
            const lockIconElement = document.getElementById('lock-status-icon');
            if (lockIconElement) {
                lockIconElement.addEventListener('click', () => {
                    fetch(`/toggle_lock/${sessionId}`, { method: 'POST' })
                        .then(response => response.json())
                        .then(data => {
                            if (!data.success) {
                                alert('Не удалось изменить статус блокировки: ' + data.message);
                            }
                        })
                        .catch(error => {
                            console.error('Error toggling lock:', error);
                            alert('Произошла ошибка при изменении статуса блокировки.');
                        });
                });
            }
        });
    </script>
</body>
</html>
""", """{% extends "base.html" %}

{% block content %}
<div class="container mt-5">
    <div class="row justify-content-center">
        <div class="col-md-6">
            <div class="card">
                <div class="card-header bg-danger text-white">
                    <h4 class="mb-0">Error</h4>
                </div>
                <div class="card-body">
                    <div class="alert alert-danger">
                        {{ error }}
                    </div>
                    <a href="{{ url_for('index') }}" class="btn btn-primary">Return to Home</a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}""", """<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeSpace - Главная</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
        }
        .container {
            margin-top: 50px;
        }
        .card {
            box-shadow: 0 4px 8px rgba(0,0,0,.05);
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <a class="navbar-brand" href="/">CodeSpace</a>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ml-auto">
                {% if current_user.is_authenticated %}
                <li class="nav-item">
                    <span class="nav-link">Привет, {{ current_user.username }}!</span>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('logout') }}">Выйти</a>
                </li>
                {% else %}
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('login') }}">Войти</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('register') }}">Регистрация</a>
                </li>
                {% endif %}
            </ul>
        </div>
    </nav>

    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header text-center bg-primary text-white">
                        <h3>Начать кодировать вместе!</h3>
                    </div>
                    <div class="card-body">
                        {% with messages = get_flashed_messages(with_categories=true) %}
                        {% if messages %}
                            {% for category, message in messages %}
                            <div class="alert alert-{{ category }}" role="alert">
                                {{ message }}
                            </div>
                            {% endfor %}
                        {% endif %}
                        {% endwith %}

                        <form action="{{ url_for('new_session') }}" method="POST" class="mb-4">
                            <div class="form-group">
                                <label for="languageSelect">Выберите язык:</label>
                                <select class="form-control" id="languageSelect" name="language">
                                    {% for lang_key, lang_info in languages.items() %}
                                    <option value="{{ lang_key }}">{{ lang_info.name }}</option>
                                    {% endfor %}
                                </select>
                            </div>
                            <button type="submit" class="btn btn-success btn-block">Создать новую сессию</button>
                        </form>

                        <hr>

                        <form action="{{ url_for('join_session') }}" method="POST">
                            <div class="form-group">
                                <label for="sessionIdInput">Или присоединиться к существующей сессии по ID:</label>
                                <input type="text" class="form-control" id="sessionIdInput" name="session_id" placeholder="Введите ID сессии" required>
                            </div>
                            <button type="submit" class="btn btn-info btn-block">Присоединиться</button>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>
""", """<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Вход</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
        }
        .container {
            margin-top: 100px;
        }
        .card {
            box-shadow: 0 4px 8px rgba(0,0,0,.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header text-center bg-primary text-white">
                        <h3>Вход в CodeSpace</h3>
                    </div>
                    <div class="card-body">
                        {% with messages = get_flashed_messages(with_categories=true) %}
                        {% if messages %}
                            {% for category, message in messages %}
                            <div class="alert alert-{{ category }}" role="alert">
                                {{ message }}
                            </div>
                            {% endfor %}
                        {% endif %}
                        {% endwith %}
                        <form method="POST">
                            <div class="form-group">
                                <label for="username">Имя пользователя:</label>
                                <input type="text" class="form-control" id="username" name="username" required>
                            </div>
                            <div class="form-group">
                                <label for="password">Пароль:</label>
                                <input type="password" class="form-control" id="password" name="password" required>
                            </div>
                            <button type="submit" class="btn btn-primary btn-block">Войти</button>
                        </form>
                        <hr>
                        <p class="text-center">Нет аккаунта? <a href="{{ url_for('register') }}">Зарегистрироваться</a></p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>
""", """<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Регистрация</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
        }
        .container {
            margin-top: 100px;
        }
        .card {
            box-shadow: 0 4px 8px rgba(0,0,0,.05);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header text-center bg-success text-white">
                        <h3>Регистрация</h3>
                    </div>
                    <div class="card-body">
                        {% with messages = get_flashed_messages(with_categories=true) %}
                        {% if messages %}
                            {% for category, message in messages %}
                            <div class="alert alert-{{ category }}" role="alert">
                                {{ message }}
                            </div>
                            {% endfor %}
                        {% endif %}
                        {% endwith %}
                        <form method="POST">
                            <div class="form-group">
                                <label for="username">Имя пользователя:</label>
                                <input type="text" class="form-control" id="username" name="username" required>
                            </div>
                            <div class="form-group">
                                <label for="password">Пароль:</label>
                                <input type="password" class="form-control" id="password" name="password" required>
                            </div>
                            <button type="submit" class="btn btn-success btn-block">Зарегистрироваться</button>
                        </form>
                        <hr>
                        <p class="text-center">Уже есть аккаунт? <a href="{{ url_for('login') }}">Войти</a></p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>
""", """{% extends "base.html" %}

{% block title %}Ваши Сессии{% endblock %}

{% block content %}
<div class="container mt-5">
    <div class="row justify-content-center">
        <div class="col-md-8">
            <div class="card shadow-lg">
                <div class="card-header bg-dark text-white d-flex justify-content-between align-items-center">
                    <h4 class="mb-0"><i class="bi bi-folder-fill me-2"></i>Ваши Сессии Кода</h4>
                    <a href="{{ url_for('logout') }}" class="btn btn-sm btn-outline-light">
                        <i class="bi bi-box-arrow-right me-1"></i> Выйти из аккаунта
                    </a>
                </div>
                <div class="card-body">
                    <form action="{{ url_for('create_new_session_route') }}" method="POST" class="mb-4">
                        <button type="submit" class="btn btn-success w-100 py-2">
                            <i class="bi bi-plus-circle me-2"></i>Создать новую сессию
                        </button>
                    </form>

                    {% if user_sessions %}
                        <h5 class="mb-3 text-secondary">Активные сессии:</h5>
                        <div class="list-group">
                            {% for session in user_sessions %}
                                <div class="list-group-item list-group-item-action d-flex justify-content-between align-items-center border-bottom py-3">
                                    <div>
                                        <h6 class="mb-1">
                                            <i class="bi bi-code-square me-2"></i>
                                            <a href="{{ url_for('join_session', session_id=session.id) }}" class="text-decoration-none fw-bold">
                                                Сессия: {{ session.id[:8] }}...
                                            </a>
                                        </h6>
                                        <small class="text-muted">
                                            Владелец: <strong>{{ session.owner_name }}</strong> 
                                            {% if session.is_owner %}(Вы){% endif %} |
                                            Участников: <span class="badge bg-info text-dark">{{ session.num_participants }}</span> |
                                            Создана: {{ session.created_at | datetimeformat }}
                                        </small>
                                    </div>
                                    <a href="{{ url_for('join_session', session_id=session.id) }}" class="btn btn-sm btn-primary">
                                        <i class="bi bi-box-arrow-in-right me-1"></i> Присоединиться
                                    </a>
                                </div>
                            {% endfor %}
                        </div>
                    {% else %}
                        <div class="alert alert-info text-center" role="alert">
                            <i class="bi bi-info-circle me-2"></i>У вас пока нет активных сессий. Создайте новую, чтобы начать!
                        </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}
""", """body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    transition: background-color 0.3s, color 0.3s;
}

/* Default Light Theme */
body.light-theme {
    background-color: #f0f2f5; /* Light grey background */
    color: #333; /* Dark text */
}
body.light-theme .session-header,
body.light-theme .card-header {
    background-color: #343a40 !important; /* Dark header */
    color: #fff;
}
body.light-theme .card {
    background-color: #fff; /* White card background */
    border: 1px solid #dee2e6;
}
body.light-theme #editor {
    background-color: #ffffff;
    color: #333;
    caret-color: #007bff; /* Blue cursor */
}
body.light-theme #output-content {
    background-color: #212529; /* Dark output background */
    color: #f8f9fa; /* Light text for output */
}
body.light-theme .list-group-item {
    background-color: #fff;
    color: #333;
    border-color: #dee2e6;
}
body.light-theme .list-group-item:hover {
    background-color: #e9ecef;
}
body.light-theme .nav-tabs .nav-link {
    background-color: #fff;
    color: #6c757d;
}
body.light-theme .nav-tabs .nav-link.active {
    background-color: #f8f9fa;
    color: #007bff;
    border-color: #dee2e6 #dee2e6 #f8f9fa;
}
body.light-theme .form-control,
body.light-theme .form-select {
    background-color: #fff;
    color: #333;
    border-color: #ced4da;
}
body.light-theme .input-group-text {
    background-color: #e9ecef;
    color: #495057;
    border-color: #ced4da;
}
body.light-theme .btn-outline-secondary {
    color: #6c757d;
    border-color: #6c757d;
}
body.light-theme .btn-outline-secondary:hover {
    background-color: #6c757d;
    color: #fff;
}

/* Dark Theme */
body.dark-theme {
    background-color: #2c2c2c; /* Darker background */
    color: #e0e0e0; /* Light text */
}
body.dark-theme .session-header,
body.dark-theme .card-header {
    background-color: #1e1e1e !important; /* Even darker header */
    color: #fff;
}
body.dark-theme .card {
    background-color: #252526; /* Dark card background */
    border: 1px solid #3a3a3a;
}
body.dark-theme #editor {
    background-color: #1e1e1e; /* Dark editor background */
    color: #d4d4d4;
    caret-color: #61afef; /* Blueish cursor for dark theme */
}
body.dark-theme #output-content {
    background-color: #1a1a1a; /* Very dark for output */
    color: #e0e0e0;
}
body.dark-theme .list-group-item {
    background-color: #252526;
    color: #e0e0e0;
    border-color: #3a3a3a;
}
body.dark-theme .list-group-item:hover {
    background-color: #333333;
}
body.dark-theme .nav-tabs .nav-link {
    background-color: #252526;
    color: #a0a0a0;
    border-color: #3a3a3a;
}
body.dark-theme .nav-tabs .nav-link.active {
    background-color: #1e1e1e;
    color: #61afef; /* Blueish active tab */
    border-bottom-color: #61afef;
}
body.dark-theme .form-control,
body.dark-theme .form-select {
    background-color: #3a3a3a;
    color: #d4d4d4;
    border-color: #555;
}
body.dark-theme .input-group-text {
    background-color: #3a3a3a;
    color: #d4d4d4;
    border-color: #555;
}
body.dark-theme .btn-outline-secondary {
    color: #a0a0a0;
    border-color: #555;
}
body.dark-theme .btn-outline-secondary:hover {
    background-color: #555;
    color: #fff;
}


/* General styling */
#editor {
    min-height: 400px; /* Ensures editor has a minimum height */
    width: 100%;
}

#output-content {
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    white-space: pre-wrap; /* Preserves whitespace and wraps text */
    word-wrap: break-word; /* Breaks long words */
    min-height: 100px; /* Minimum height for output */
    font-size: 0.9em;
}

.remote-cursor {
    position: absolute;
    width: 2px;
    height: 1.1em; /* Matches line height */
    background-color: red; /* Default color */
    z-index: 10;
    pointer-events: none; /* Allow clicks to pass through */
    animation: blink-cursor 1s infinite;
}

.remote-cursor-label {
    position: absolute;
    padding: 2px 5px;
    border-radius: 3px;
    font-size: 0.7em;
    color: white;
    white-space: nowrap;
    transform: translateX(-50%); /* Center horizontally */
    z-index: 10;
    pointer-events: none; /* Allow clicks to pass through */
}

@keyframes blink-cursor {
    0% { opacity: 1; }
    50% { opacity: 0; }
    100% { opacity: 1; }
}

/* Theme toggle button positioning */
.theme-toggle-container {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 1000; /* Ensure it's above other content */
}

/* Toast Container Styling */
.toast-container {
    z-index: 1050; /* Above modals and other elements */
}

.toast {
    opacity: 0.95; /* Slightly transparent */
}

.toast .toast-body {
    font-weight: 500;
}
""", """import subprocess
import os
import tempfile

def execute_bash(code):
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.sh') as temp_file:
            temp_file.write(code)
            temp_file_name = temp_file.name
        
        # Делаем файл исполняемым
        os.chmod(temp_file_name, 0o755)

        result = subprocess.run(
            ['bash', temp_file_name],
            capture_output=True,
            text=True,
            timeout=10 # 10-секундный таймаут
        )
        os.unlink(temp_file_name)

        if result.returncode != 0:
            return {'error': f'Ошибка выполнения Bash:\n{result.stderr}', 'output': result.stdout}
        return {'output': result.stdout}
    except FileNotFoundError:
        return {'error': 'Bash интерпретатор не найден. Убедитесь, что Bash установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': 'Выполнение кода превысило лимит времени (10 секунд).'}
    except Exception as e:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': f'Внутренняя ошибка сервера: {e}'}

""", """# cpp_exec.py
import subprocess
import os
import tempfile

def execute_cpp(code):
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'main.cpp')
        exe_name = os.path.join(temp_dir, 'main')
        
        with open(file_name, 'w') as f:
            f.write(code)
        
        compile_result = subprocess.run(
            ['g++', file_name, '-o', exe_name],
            capture_output=True,
            text=True
        )
        
        if compile_result.returncode != 0:
            return {
                'error': 'Compilation failed',
                'output': compile_result.stderr
            }
        
        run_result = subprocess.run(
            [exe_name],
            capture_output=True,
            text=True,
            timeout=10
        )
        
        if run_result.returncode != 0:
            return {
                'error': f'Execution failed with return code {run_result.returncode}',
                'output': run_result.stderr
            }
            
        return {'output': run_result.stdout}
    except subprocess.TimeoutExpired:
        return {'error': 'Execution timed out'}
    except Exception as e:
        return {'error': str(e)}
    finally:
        if 'temp_dir' in locals():
            for file in os.listdir(temp_dir):
                os.remove(os.path.join(temp_dir, file))
            os.rmdir(temp_dir)""", """import subprocess
import os
import tempfile

def execute_csharp(code):
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'Program.cs')
        exe_name = os.path.join(temp_dir, 'program')
        
        with open(file_name, 'w') as f:
            f.write(code)
        
        compile_result = subprocess.run(
            ['mcs', file_name, '-out:' + exe_name],
            capture_output=True,
            text=True
        )
        
        if compile_result.returncode != 0:
            return {
                'error': 'Compilation failed',
                'output': compile_result.stderr
            }
        
        run_result = subprocess.run(
            ['mono', exe_name],
            capture_output=True,
            text=True,
            timeout=10
        )
        
        if run_result.returncode != 0:
            return {
                'error': f'Execution failed with return code {run_result.returncode}',
                'output': run_result.stderr
            }
            
        return {'output': run_result.stdout}
    except subprocess.TimeoutExpired:
        return {'error': 'Execution timed out'}
    except Exception as e:
        return {'error': str(e)}
    finally:
        if 'temp_dir' in locals():
            for file in os.listdir(temp_dir):
                os.remove(os.path.join(temp_dir, file))
            os.rmdir(temp_dir)""", """import subprocess
import os
import tempfile
import shutil

def execute_dart(code):
    temp_dir = None
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'main.dart')
        
        with open(file_name, 'w') as f:
            f.write(code)

        # Выполняем Dart код с использованием dart run
        # Или можно использовать dart compile exe для создания исполняемого файла
        result = subprocess.run(
            ['dart', 'run', file_name],
            capture_output=True,
            text=True,
            cwd=temp_dir,
            timeout=15 # Таймаут для выполнения Dart
        )

        if result.returncode != 0:
            return {
                'error': f'Ошибка выполнения Dart (код: {result.returncode})\n{result.stderr}',
                'output': result.stdout
            }

        return {'output': result.stdout}
    except FileNotFoundError:
        return {'error': 'Dart SDK не найден. Убедитесь, что Dart установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired as e:
        return {'error': f'Выполнение кода Dart превысило лимит времени (15 секунд).'}
    except Exception as e:
        return {'error': f'Внутренняя ошибка сервера: {e}'}
    finally:
        if temp_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

""", """import subprocess
import os
import tempfile
import shutil

def execute_go(code):
    temp_dir = None
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'main.go')
        exe_name = os.path.join(temp_dir, 'main') # Для скомпилированного исполняемого файла

        with open(file_name, 'w') as f:
            f.write(code)

        # Компилируем Go код
        compile_result = subprocess.run(
            ['go', 'build', '-o', exe_name, file_name],
            capture_output=True,
            text=True,
            cwd=temp_dir, # Компилируем во временной директории
            timeout=10
        )

        if compile_result.returncode != 0:
            return {
                'error': 'Ошибка компиляции Go:\n' + compile_result.stderr
            }

        # Запускаем скомпилированный исполняемый файл
        run_result = subprocess.run(
            [exe_name],
            capture_output=True,
            text=True,
            timeout=10 # 10-секундный таймаут
        )

        if run_result.returncode != 0:
            return {
                'error': f'Ошибка выполнения (код: {run_result.returncode})\n{run_result.stderr}',
                'output': run_result.stdout
            }

        return {'output': run_result.stdout}
    except FileNotFoundError:
        return {'error': 'Go компилятор не найден. Убедитесь, что Go установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired as e:
        return {'error': f'Операция ({e.cmd[0]}) превысила лимит времени. (Таймаут: 10с на компиляцию/выполнение)'}
    except Exception as e:
        return {'error': f'Внутренняя ошибка сервера: {e}'}
    finally:
        if temp_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

""", """import subprocess
import os
import tempfile
import shutil

def execute_haskell(code):
    temp_dir = None
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'main.hs')
        exe_name = os.path.join(temp_dir, 'main')

        with open(file_name, 'w') as f:
            f.write(code)

        # Компилируем Haskell код с GHC
        compile_result = subprocess.run(
            ['ghc', file_name, '-o', exe_name],
            capture_output=True,
            text=True,
            cwd=temp_dir,
            timeout=20 # Компиляция Haskell может быть долгой
        )

        if compile_result.returncode != 0:
            return {
                'error': 'Ошибка компиляции Haskell:\n' + compile_result.stderr
            }

        # Запускаем скомпилированный исполняемый файл
        run_result = subprocess.run(
            [exe_name],
            capture_output=True,
            text=True,
            timeout=10
        )

        if run_result.returncode != 0:
            return {
                'error': f'Ошибка выполнения (код: {run_result.returncode})\n{run_result.stderr}',
                'output': run_result.stdout
            }

        return {'output': run_result.stdout}
    except FileNotFoundError:
        return {'error': 'Haskell компилятор (ghc) не найден. Убедитесь, что Haskell установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired as e:
        return {'error': f'Операция ({e.cmd[0]}) превысила лимит времени. (Таймаут: 20с на компиляцию, 10с на выполнение)'}
    except Exception as e:
        return {'error': f'Внутренняя ошибка сервера: {e}'}
    finally:
        if temp_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

""", """import subprocess
import os
import tempfile

def execute_java(code):
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'Main.java')
        
        with open(file_name, 'w') as f:
            f.write(code)
        
        compile_result = subprocess.run(
            ['javac', file_name],
            cwd=temp_dir,
            capture_output=True,
            text=True
        )
        
        if compile_result.returncode != 0:
            return {
                'error': 'Compilation failed',
                'output': compile_result.stderr
            }
        
        run_result = subprocess.run(
            ['java', '-cp', temp_dir, 'Main'],
            capture_output=True,
            text=True,
            timeout=10
        )
        
        if run_result.returncode != 0:
            return {
                'error': f'Execution failed with return code {run_result.returncode}',
                'output': run_result.stderr
            }
            
        return {'output': run_result.stdout}
    except subprocess.TimeoutExpired:
        return {'error': 'Execution timed out'}
    except Exception as e:
        return {'error': str(e)}
    finally:
        if 'temp_dir' in locals():
            for file in os.listdir(temp_dir):
                os.remove(os.path.join(temp_dir, file))
            os.rmdir(temp_dir)""", """import subprocess
import os
import tempfile

def execute_javascript(code):
    try:
        with tempfile.NamedTemporaryFile(suffix='.js', delete=False) as f:
            f.write(code.encode())
            f.close()
            result = subprocess.run(
                ['node', f.name],
                capture_output=True,
                text=True,
                timeout=10
            )
            os.unlink(f.name)
            
            if result.returncode != 0:
                return {
                    'error': f'JavaScript execution failed with return code {result.returncode}',
                    'output': result.stderr
                }
            return {'output': result.stdout}
    except subprocess.TimeoutExpired:
        return {'error': 'Execution timed out'}
    except Exception as e:
        return {'error': str(e)}""", """import subprocess
import os
import tempfile

def execute_julia(code):
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.jl') as temp_file:
            temp_file.write(code)
            temp_file_name = temp_file.name

        result = subprocess.run(
            ['julia', temp_file_name],
            capture_output=True,
            text=True,
            timeout=15 # 15-секундный таймаут
        )
        os.unlink(temp_file_name)

        if result.returncode != 0:
            return {'error': f'Ошибка выполнения Julia:\n{result.stderr}', 'output': result.stdout}
        return {'output': result.stdout}
    except FileNotFoundError:
        return {'error': 'Julia интерпретатор не найден. Убедитесь, что Julia установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': 'Выполнение кода превысило лимит времени (15 секунд).'}
    except Exception as e:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': f'Внутренняя ошибка сервера: {e}'}

""", """import subprocess
import os
import tempfile
import shutil

def execute_kotlin(code):
    temp_dir = None
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'Main.kt') # Kotlin по соглашению
        jar_name = os.path.join(temp_dir, 'main.jar')

        # Обернем код в стандартную main функцию, если ее нет
        # Это упрощенный подход, так как пользователь может ввести полный класс
        kotlin_code_wrapped = f"""
fun main() {{
{code}
}}
"""
        with open(file_name, 'w') as f:
            f.write(kotlin_code_wrapped)

        # Компилируем Kotlin код в JAR
        compile_result = subprocess.run(
            ['kotlinc', file_name, '-include-runtime', '-d', jar_name],
            capture_output=True,
            text=True,
            cwd=temp_dir,
            timeout=20 # Компиляция Kotlin может занять время
        )

        if compile_result.returncode != 0:
            return {
                'error': 'Ошибка компиляции Kotlin:\n' + compile_result.stderr
            }

        # Запускаем JAR файл
        run_result = subprocess.run(
            ['java', '-jar', jar_name],
            capture_output=True,
            text=True,
            timeout=10
        )

        if run_result.returncode != 0:
            return {
                'error': f'Ошибка выполнения (код: {run_result.returncode})\n{run_result.stderr}',
                'output': run_result.stdout
            }

        return {'output': run_result.stdout}
    except FileNotFoundError:
        return {'error': 'Kotlin компилятор (kotlinc) или Java (java) не найдены. Убедитесь, что они установлены и доступны в PATH.'}
    except subprocess.TimeoutExpired as e:
        return {'error': f'Операция ({e.cmd[0]}) превысила лимит времени. (Таймаут: 20с на компиляцию, 10с на выполнение)'}
    except Exception as e:
        return {'error': f'Внутренняя ошибка сервера: {e}'}
    finally:
        if temp_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

""", """import subprocess
import os
import tempfile

def execute_lua(code):
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.lua') as temp_file:
            temp_file.write(code)
            temp_file_name = temp_file.name

        result = subprocess.run(
            ['lua', temp_file_name],
            capture_output=True,
            text=True,
            timeout=10 # 10-секундный таймаут
        )
        os.unlink(temp_file_name)

        if result.returncode != 0:
            return {'error': f'Ошибка выполнения Lua:\n{result.stderr}', 'output': result.stdout}
        return {'output': result.stdout}
    except FileNotFoundError:
        return {'error': 'Lua интерпретатор не найден. Убедитесь, что Lua установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': 'Выполнение кода превысило лимит времени (10 секунд).'}
    except Exception as e:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': f'Внутренняя ошибка сервера: {e}'}

""", """import subprocess
import os
import tempfile

def execute_perl(code):
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.pl') as temp_file:
            temp_file.write(code)
            temp_file_name = temp_file.name

        result = subprocess.run(
            ['perl', temp_file_name],
            capture_output=True,
            text=True,
            timeout=10 # 10-секундный таймаут
        )
        os.unlink(temp_file_name)

        if result.returncode != 0:
            return {'error': f'Ошибка выполнения Perl:\n{result.stderr}', 'output': result.stdout}
        return {'output': result.stdout}
    except FileNotFoundError:
        return {'error': 'Perl интерпретатор не найден. Убедитесь, что Perl установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': 'Выполнение кода превысило лимит времени (10 секунд).'}
    except Exception as e:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': f'Внутренняя ошибка сервера: {e}'}

""", """import subprocess
import os
import tempfile

def execute_php(code):
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.php') as temp_file:
            temp_file.write(code)
            temp_file_name = temp_file.name

        result = subprocess.run(
            ['php', temp_file_name],
            capture_output=True,
            text=True,
            timeout=10 # 10-секундный таймаут
        )
        os.unlink(temp_file_name)

        if result.returncode != 0:
            return {'error': f'Ошибка выполнения PHP:\n{result.stderr}', 'output': result.stdout}
        return {'output': result.stdout}
    except FileNotFoundError:
        return {'error': 'PHP интерпретатор не найден. Убедитесь, что PHP установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': 'Выполнение кода превысило лимит времени (10 секунд).'}
    except Exception as e:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': f'Внутренняя ошибка сервера: {e}'}

""", """import subprocess
import os
import tempfile

def execute_python(code):
    try:
        # Создаем временный файл для записи кода
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.py') as temp_file:
            temp_file.write(code)
            temp_file_name = temp_file.name

        # Выполняем Python код с использованием subprocess
        # Добавляем таймаут, чтобы предотвратить бесконечные циклы
        result = subprocess.run(
            ['python', temp_file_name],
            capture_output=True,
            text=True,
            timeout=10  # 10-секундный таймаут
        )

        # Удаляем временный файл
        os.unlink(temp_file_name)

        if result.returncode != 0:
            return {
                'error': f'Ошибка выполнения (код: {result.returncode})\n{result.stderr}',
                'output': result.stdout # Иногда stdout может быть даже при ошибке
            }
        else:
            return {'output': result.stdout}
    except subprocess.TimeoutExpired:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': 'Выполнение кода превысило лимит времени (10 секунд).'}
    except Exception as e:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': f'Внутренняя ошибка сервера: {e}'}

""", """import subprocess
import os
import tempfile

def execute_r(code):
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.R') as temp_file:
            temp_file.write(code)
            temp_file_name = temp_file.name

        result = subprocess.run(
            ['Rscript', temp_file_name],
            capture_output=True,
            text=True,
            timeout=10 # 10-секундный таймаут
        )
        os.unlink(temp_file_name)

        if result.returncode != 0:
            return {'error': f'Ошибка выполнения R:\n{result.stderr}', 'output': result.stdout}
        return {'output': result.stdout}
    except FileNotFoundError:
        return {'error': 'Rscript не найден. Убедитесь, что R установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': 'Выполнение кода превысило лимит времени (10 секунд).'}
    except Exception as e:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': f'Внутренняя ошибка сервера: {e}'}

""", """import subprocess
import os
import tempfile

def execute_ruby(code):
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.rb') as temp_file:
            temp_file.write(code)
            temp_file_name = temp_file.name

        result = subprocess.run(
            ['ruby', temp_file_name],
            capture_output=True,
            text=True,
            timeout=10 # 10-секундный таймаут
        )
        os.unlink(temp_file_name)

        if result.returncode != 0:
            return {'error': f'Ошибка выполнения Ruby:\n{result.stderr}', 'output': result.stdout}
        return {'output': result.stdout}
    except FileNotFoundError:
        return {'error': 'Ruby интерпретатор не найден. Убедитесь, что Ruby установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': 'Выполнение кода превысило лимит времени (10 секунд).'}
    except Exception as e:
        if 'temp_file_name' in locals() and os.path.exists(temp_file_name):
            os.unlink(temp_file_name)
        return {'error': f'Внутренняя ошибка сервера: {e}'}

""", """import subprocess
import os
import tempfile
import shutil

def execute_rust(code):
    temp_dir = None
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'main.rs')
        exe_name = os.path.join(temp_dir, 'main') # Исполняемый файл по умолчанию

        with open(file_name, 'w') as f:
            f.write(code)

        # Компилируем Rust код
        compile_result = subprocess.run(
            ['rustc', file_name, '-o', exe_name],
            capture_output=True,
            text=True,
            cwd=temp_dir,
            timeout=20 # Rust компиляция может быть долгой
        )

        if compile_result.returncode != 0:
            return {
                'error': 'Ошибка компиляции Rust:\n' + compile_result.stderr
            }

        # Запускаем скомпилированный исполняемый файл
        run_result = subprocess.run(
            [exe_name],
            capture_output=True,
            text=True,
            timeout=10 # Таймаут для выполнения
        )

        if run_result.returncode != 0:
            return {
                'error': f'Ошибка выполнения (код: {run_result.returncode})\n{run_result.stderr}',
                'output': run_result.stdout
            }

        return {'output': run_result.stdout}
    except FileNotFoundError:
        return {'error': 'Rust компилятор (rustc) не найден. Убедитесь, что Rust установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired as e:
        return {'error': f'Операция ({e.cmd[0]}) превысила лимит времени. (Таймаут: 20с на компиляцию, 10с на выполнение)'}
    except Exception as e:
        return {'error': f'Внутренняя ошибка сервера: {e}'}
    finally:
        if temp_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

""", """import subprocess
import os
import tempfile
import shutil

def execute_scala(code):
    temp_dir = None
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'Main.scala')
        class_name = "Main" # Имя класса, если он обернут

        # Обернем код в объект Main, если его нет, для запуска
        scala_code_wrapped = f"""
object Main {{
  def main(args: Array[String]): Unit = {{
{code}
  }}
}}
"""
        with open(file_name, 'w') as f:
            f.write(scala_code_wrapped)

        # Компилируем Scala код
        compile_result = subprocess.run(
            ['scalac', file_name],
            capture_output=True,
            text=True,
            cwd=temp_dir,
            timeout=20 # Компиляция Scala может быть долгой
        )

        if compile_result.returncode != 0:
            return {
                'error': 'Ошибка компиляции Scala:\n' + compile_result.stderr
            }

        # Запускаем скомпилированный класс Scala
        run_result = subprocess.run(
            ['scala', class_name],
            capture_output=True,
            text=True,
            cwd=temp_dir,
            timeout=10
        )

        if run_result.returncode != 0:
            return {
                'error': f'Ошибка выполнения (код: {run_result.returncode})\n{run_result.stderr}',
                'output': run_result.stdout
            }

        return {'output': run_result.stdout}
    except FileNotFoundError:
        return {'error': 'Scala компилятор (scalac) или среда выполнения (scala) не найдены. Убедитесь, что Scala установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired as e:
        return {'error': f'Операция ({e.cmd[0]}) превысила лимит времени. (Таймаут: 20с на компиляцию, 10с на выполнение)'}
    except Exception as e:
        return {'error': f'Внутренняя ошибка сервера: {e}'}
    finally:
        if temp_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

""", """import subprocess
import os
import tempfile
import shutil

def execute_swift(code):
    temp_dir = None
    try:
        temp_dir = tempfile.mkdtemp()
        file_name = os.path.join(temp_dir, 'main.swift')
        exe_name = os.path.join(temp_dir, 'main')

        with open(file_name, 'w') as f:
            f.write(code)

        # Компилируем Swift код
        compile_result = subprocess.run(
            ['swiftc', file_name, '-o', exe_name],
            capture_output=True,
            text=True,
            cwd=temp_dir,
            timeout=30 # Swift компиляция может быть очень долгой
        )

        if compile_result.returncode != 0:
            return {
                'error': 'Ошибка компиляции Swift:\n' + compile_result.stderr
            }

        # Запускаем скомпилированный исполняемый файл
        run_result = subprocess.run(
            [exe_name],
            capture_output=True,
            text=True,
            timeout=10
        )

        if run_result.returncode != 0:
            return {
                'error': f'Ошибка выполнения (код: {run_result.returncode})\n{run_result.stderr}',
                'output': run_result.stdout
            }

        return {'output': run_result.stdout}
    except FileNotFoundError:
        return {'error': 'Swift компилятор (swiftc) не найден. Убедитесь, что Swift установлен и доступен в PATH.'}
    except subprocess.TimeoutExpired as e:
        return {'error': f'Операция ({e.cmd[0]}) превысила лимит времени. (Таймаут: 30с на компиляцию, 10с на выполнение)'}
    except Exception as e:
        return {'error': f'Внутренняя ошибка сервера: {e}'}
    finally:
        if temp_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

""", """import subprocess
import os
import tempfile
import shutil

def execute_typescript(code):
    temp_dir = None
    try:
        temp_dir = tempfile.mkdtemp()
        ts_file_name = os.path.join(temp_dir, 'main.ts')
        js_file_name = os.path.join(temp_dir, 'main.js')

        with open(ts_file_name, 'w') as f:
            f.write(code)

        # Компилируем TypeScript в JavaScript с помощью tsc
        # Убедитесь, что TypeScript (tsc) установлен глобально или в PATH
        compile_result = subprocess.run(
            ['tsc', ts_file_name, '--outFile', js_file_name],
            capture_output=True,
            text=True,
            cwd=temp_dir,
            timeout=15 # Таймаут для компиляции TypeScript
        )

        if compile_result.returncode != 0:
            return {
                'error': 'Ошибка компиляции TypeScript:\n' + compile_result.stderr
            }

        # Запускаем скомпилированный JavaScript с помощью Node.js
        run_result = subprocess.run(
            ['node', js_file_name],
            capture_output=True,
            text=True,
            timeout=10
        )

        if run_result.returncode != 0:
            return {
                'error': f'Ошибка выполнения (код: {run_result.returncode})\n{run_result.stderr}',
                'output': run_result.stdout
            }

        return {'output': run_result.stdout}
    except FileNotFoundError:
        return {'error': 'TypeScript компилятор (tsc) или Node.js не найдены. Убедитесь, что они установлены и доступны в PATH.'}
    except subprocess.TimeoutExpired as e:
        return {'error': f'Операция ({e.cmd[0]}) превысила лимит времени. (Таймаут: 15с на компиляцию, 10с на выполнение)'}
    except Exception as e:
        return {'error': f'Внутренняя ошибка сервера: {e}'}
    finally:
        if temp_dir and os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

"""
